const مدير = require( ../lib/isAdmin );
const مخزن = require( ../lib/lightweight_store );

async function أمر_حذف(سوك, معرف_الدردشة, رسالة, معرف_المرسل) {
    try {
        const { مرسل_مدير, بوت_مدير } = await مدير(سوك, معرف_الدردشة, معرف_المرسل);

        if (!بوت_مدير) {
            await سوك.sendMessage(معرف_الدردشة, { text:  أحتاج أن أكون مديراً لحذف الرسائل.  }, { quoted: رسالة });
            return;
        }

        if (!مرسل_مدير) {
            await سوك.sendMessage(معرف_الدردشة, { text:  فقط المدراء يمكنهم استخدام أمر .delete.  }, { quoted: رسالة });
            return;
        }

        // تحديد المستخدم الهدف والعدد
        const نص = رسالة.message?.conversation || رسالة.message?.extendedTextMessage?.text ||   ;
        const الأجزاء = نص.trim().split(/\s+/);
        let وسيط_العدد = null;
        
        // التحقق إذا تم توفير رقم
        if (الأجزاء.length > 1) {
            const ربما_رقم = parseInt(الأجزاء[1], 10);
            if (!isNaN(ربما_رقم) && ربما_رقم > 0) {
                وسيط_العدد = Math.min(ربما_رقم, 50);
            }
        }
        
        // التحقق إذا كان المستخدم يرد على رسالة
        const معلومات_السياق = رسالة.message?.extendedTextMessage?.contextInfo || {};
        const المشارك_المجيب = معلومات_السياق.participant || null;
        const المذكور = Array.isArray(معلومات_السياق.mentionedJid) && معلومات_السياق.mentionedJid.length > 0 ? معلومات_السياق.mentionedJid[0] : null;
        
        // إذا لم يتم توفير رقم ولكن هناك رد على رسالة، الافتراضي هو 1
        if (وسيط_العدد === null && المشارك_المجيب) {
            وسيط_العدد = 1;
        }
        // إذا لم يتم توفير رقم وليس هناك رد/ذكر، عرض رسالة الاستخدام
        else if (وسيط_العدد === null && !المشارك_المجيب && !المذكور) {
            await سوك.sendMessage(معرف_الدردشة, { 
                text:  ❌ يرجى تحديد عدد الرسائل المراد حذفها.\n\nطريقة الاستخدام:\n• `.del 5` - حذف آخر 5 رسائل من المجموعة\n• `.del 3 @مستخدم` - حذف آخر 3 رسائل من @مستخدم\n• `.del 2` (الرد على رسالة) - حذف آخر رسالتين من المستخدم المجاب 
            }, { quoted: رسالة });
            return;
        }
        // إذا لم يتم توفير رقم ولكن تم ذكر مستخدم، الافتراضي هو 1
        else if (وسيط_العدد === null && المذكور) {
            وسيط_العدد = 1;
        }


        // تحديد المستخدم الهدف: المجاب > المذكور؛ إذا لم يكن أي منهما، حذف آخر رسائل N من المجموعة
        let مستخدم_الهدف = null;
        let معرف_الرسالة_المجابة = null;
        let حذف_رسائل_المجموعة = false;
        
        if (المشارك_المجيب && معلومات_السياق.stanzaId) {
            مستخدم_الهدف = المشارك_المجيب;
            معرف_الرسالة_المجابة = معلومات_السياق.stanzaId;
        } else if (المذكور) {
            مستخدم_الهدف = المذكور;
        } else {
            // لم يتم ذكر أو الرد على مستخدم - حذف آخر رسائل N من المجموعة
            حذف_رسائل_المجموعة = true;
        }

        // جمع آخر رسائل N من مستخدم_الهدف في هذه الدردشة
        const رسائل_الدردشة = Array.isArray(مخزن.messages[معرف_الدردشة]) ? مخزن.messages[معرف_الدردشة] : [];
        // الأحدث آخر؛ ننتقل من النهاية إلى الخلف
        const للحذف = [];
        const معرفات_المشاهدة = new Set();

        if (حذف_رسائل_المجموعة) {
            // حذف آخر رسائل N من المجموعة (أي مستخدم)
            for (let i = رسائل_الدردشة.length - 1; i >= 0 && للحذف.length < وسيط_العدد; i--) {
                const م = رسائل_الدردشة[i];
                if (!معرفات_المشاهدة.has(م.key.id)) {
                    // تخطي رسائل البروتوكول/النظام، رسائل البوت نفسها، ورسالة الأمر الحالية
                    if (!م.message?.protocolMessage && 
                        !م.key.fromMe && 
                        م.key.id !== رسالة.key.id) {
                        للحذف.push(م);
                        معرفات_المشاهدة.add(م.key.id);
                    }
                }
            }
        } else {
            // المنطق الأصلي لمستخدم محدد
            // إذا كان هناك رد، أعط الأولوية لحذف الرسالة المجابة بالضبط أولاً (تحسب ضمن N)
            if (معرف_الرسالة_المجابة) {
                const مجاب_في_المخزن = رسائل_الدردشة.find(م => م.key.id === معرف_الرسالة_المجابة && (م.key.participant || م.key.remoteJid) === مستخدم_الهدف);
                if (مجاب_في_المخزن) {
                    للحذف.push(مجاب_في_المخزن);
                    معرفات_المشاهدة.add(مجاب_في_المخزن.key.id);
                } else {
                    // إذا لم يتم العثور في المخزن، لا تزال تحاول الحذف مباشرة
                    try {
                        await سوك.sendMessage(معرف_الدردشة, {
                            delete: {
                                remoteJid: معرف_الدردشة,
                                fromMe: false,
                                id: معرف_الرسالة_المجابة,
                                participant: المشارك_المجيب
                            }
                        });
                        // عد هذا كرسالة محذوفة واحدة وقلل العدد المطلوب
                        وسيط_العدد = Math.max(0, وسيط_العدد - 1);
                    } catch {}
                }
            }
            for (let i = رسائل_الدردشة.length - 1; i >= 0 && للحذف.length < وسيط_العدد; i--) {
                const م = رسائل_الدردشة[i];
                const المشارك = م.key.participant || م.key.remoteJid;
                if (المشارك === مستخدم_الهدف && !معرفات_المشاهدة.has(م.key.id)) {
                    // تخطي رسائل البروتوكول/النظام
                    if (!م.message?.protocolMessage) {
                        للحذف.push(م);
                        معرفات_المشاهدة.add(م.key.id);
                    }
                }
            }
        }

        if (للحذف.length === 0) {
            const رسالة_الخطأ = حذف_رسائل_المجموعة 
                ?  لم يتم العثور على رسائل حديثة في المجموعة للحذف.  
                :  لم يتم العثور على رسائل حديثة للمستخدم الهدف. ;
            await سوك.sendMessage(معرف_الدردشة, { text: رسالة_الخطأ }, { quoted: رسالة });
            return;
        }

        // الحذف بالتتابع مع تأخير صغير
        for (const م of للحذف) {
            try {
                const مشارك_الرسالة = حذف_رسائل_المجموعة 
                    ? (م.key.participant || م.key.remoteJid) 
                    : (م.key.participant || مستخدم_الهدف);
                await سوك.sendMessage(معرف_الدردشة, {
                    delete: {
                        remoteJid: معرف_الدردشة,
                        fromMe: false,
                        id: م.key.id,
                        participant: مشارك_الرسالة
                    }
                });
                await new Promise(ر => setTimeout(ر, 300));
            } catch (هـ) {
                // استمرار
            }
        }

    
    } catch (خطأ) {
        await سوك.sendMessage(معرف_الدردشة, { text:  فشل في حذف الرسائل.  }, { quoted: رسالة });
    }
}

module.exports = أمر_حذف;